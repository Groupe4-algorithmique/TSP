# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name compute_distance_Rcpp
#' @title calcul de distance selon un ordre de villes en Rcpp.
#' @param G : la matrice des distances.
#' @param cities : vecteur des villes à visiter.
#' @param start_city : la ville de début du voyage.
#' @usage compute_distance_Rcpp(G,cities,start_city)
#' @return la distance totale parcourue
#' @examples 
#' G = matrix(runif(4*4,min=10,max=50),nrow=4,ncol=4)
#' G = G %*% t(G) # rendre G symétrique
#' diag(G) = 0 # annuler la diagonale de G
#' ## la symétrie de G n'est pas nécessaire.
#' start_city = 0 # la ville de Départ.
#' cities = c(1,2,3) # un ordre de ville à visiter.
#' distance = compute_distance_Rcpp(G,cities,start_city)
compute_distance_Rcpp <- function(G, cities, start_city) {
    .Call(`_tspp_compute_distance_Rcpp`, G, cities, start_city)
}

#' @name  naive_method_Rcpp
#' @title Test de toutes les permutations possibles en Rcpp.
#' @param G : la matrice des distances.
#' @param cities : vecteur des villes à visiter.
#' @param start_city : la ville de début du voyage.
#' @usage naive_method_Rcpp(G,cities,start_city)
#' @return la séquence des villes qui donnent la moindre en distance.
#' @examples 
#' G = matrix(runif(4*4 , min = 10, max = 50),nrow=4)
#' G = G %*% t(G) # rendre G symétrique (n'est pas nécessaire.)
#' diag(G) = 0 # annuler la diagonale de G
#' ## la symétrie de G n'est pas nécessaire.
#' start_city = 0 # la ville de Départ.
#' cities = c(1,2,3)  # un ordre de ville à visiter.
#' results = naive_method_Rcpp(G,cities,start_city)
#' results['path_optimal'] # l'ordre des villes optimales
#' results['dist_optimal'] # la distance obtenue avec l'ordre des villes optimales.
naive_method_Rcpp <- function(G, cities, start_city) {
    .Call(`_tspp_naive_method_Rcpp`, G, cities, start_city)
}

.get_subsets_Rcpp <- function(set, p) {
    .Call(`_tspp_get_subsets_Rcpp`, set, p)
}

.to_String <- function(v) {
    .Call(`_tspp_to_String`, v)
}

.construct_C_S_k_Rcpp <- function(C, Subset, k, G) {
    .Call(`_tspp_construct_C_S_k_Rcpp`, C, Subset, k, G)
}

.search_min_C_S_k_Rcpp <- function(C_S_k) {
    .Call(`_tspp_search_min_C_S_k_Rcpp`, C_S_k)
}

.delete_element <- function(vec, el) {
    .Call(`_tspp_delete_element`, vec, el)
}

.str_to_int <- function(numStr) {
    .Call(`_tspp_str_to_int`, numStr)
}

#' @name  held_karp_Rcpp
#' @title L'algorithme de Held_karp en Rcpp.
#' @param G : la matrice des distances.
#' @param n : le nombre de villes.
#' @usage held_karp_Rcpp(G,n)
#' @return La séquence des villes qui donnent la moindre en distance et la distance optimale.
#' @examples 
#' G = matrix(runif(4*4 , min = 10, max = 50),nrow=4)
#' G = G %*% t(G) # rendre G symétrique (n'est pas nécessaire.).
#' diag(G) = 0 # annuler la diagonale de G.
#' n = 4 # nombre de villes.
#' results = held_karp_Rcpp(G,n)
#' results['path_opt'] # l'ordre optimale des villes.
#' results['dist_opt'] # la distance totale optimale.
held_karp_Rcpp <- function(G, n) {
    .Call(`_tspp_held_karp_Rcpp`, G, n)
}

